# cache_streamer

An incomplete Rust and tokio-based HTTP server designed as a caching reverse proxy for binary files (think images and videos). It is intended to handle range requests, as well as standard GET/HEAD requests.

TODO: testing, actually handle input ranges, more headers, TTL-based expiration, if-modified-since, if-none-match, if-range

### Why not nginx

- proxy_cache appears to download the full file first before starting to deliver it
- Noticeable delay before stream starts for larger files
- Difficult to completely control headers without lua/openresty
- Difficult to implement access control for purging without lua/openresty

### Why not varnish

- No internal event loop. Varnish makes heavy use of OS threading to handle connections
- No support connecting to HTTPS proxy backends unless you pay enterprise money (which I don't have)
  * You can alternatively use something like stunnel, but then you need even more threads
- VCL can't really do anything useful
- VCL's lack of usefulness means useful functionality is written in inscrutable and unsafe C extensions

## Internal architecture

LRU cache of reference-counted stream objects, each of which contains a sparse mapping of reference-counted file bytes.

When called, the service checks if the requested path already exists in the cache. If it does, then the cached stream object is used to generate the response. Otherwise, an upstream HTTP request matching the call is made, and a new stream object is created if the response is success (200-206). Otherwise, the upstream response status and body are passed through to the client.

Each stream object must be created with the body of a successful response. During creation, the stream object spawns an async subtask to finish downloading the response body into the stream object's sparse mapping. Clients may also request ranges which have not yet been downloaded. To handle this case, the stream object keeps a separate sparse mapping of ranges which have in-progress or completed downloads. If any part of a requested range is missing from this mapping, it dynamically spawns an async subtask to download gaps.

Each individual streaming client has its own task which is spawned by the web server. The client will begin by reading as many bytes from the sparse map as possible until either its request is satisfied, or no more bytes are available yet. In the latter case, it will wait for more bytes to become available by a notification condition generated by the download subtasks, which is signaled when the sparse mapping has changed. If any downloading subtask panics, then all in-progress client streams receive notification and abort.
