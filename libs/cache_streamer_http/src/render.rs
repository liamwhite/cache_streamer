use cache_streamer_lib::types::{RequestRange, ResponseRange};
use headers::{ContentLength, ContentRange, HeaderMap, HeaderMapExt};
use range_header::ByteRangeBuilder;

/// Returns a [`HeaderMap`] containing the required headers to fetch the given [`RequestRange`].
///
/// If the range is [`RequestRange::None`], no headers are added. Otherwise, the appropriate
/// `range` header will be added.
///
/// [`None`] will be returned only if the range cannot be converted.
pub fn request_range_headers(range: &RequestRange) -> Option<HeaderMap> {
    let mut headers = HeaderMap::new();
    let builder = ByteRangeBuilder::new();
    let builder = match range {
        RequestRange::None => Ok(builder),
        RequestRange::AllFrom(start) => builder.range(l(*start)?..),
        RequestRange::FromTo(start, end) => builder.range(l(*start)?..l(*end)?.checked_sub(1)?),
        RequestRange::Last(size) => builder.suffix(l(*size)?),
    };

    let header = builder.ok()?.finish().ok()?;
    headers.typed_insert(header);

    Some(headers)
}

/// Adds the appropriate HTTP `content-length` and `content-range` headers from
/// the given [`ResponseRange`] to the given [`HeaderMap`].
///
/// If the response was not generated by a range request, then only the `content-length`
/// will be set.
///
/// Otherwise, the `content-length` header will be set to the length of the returned
/// range, and the `content-range` header will be set to include the returned range as
/// well as the complete length.
///
/// [`None`] will be returned only if the range cannot be converted.
pub fn put_response_range(headers: HeaderMap, range: ResponseRange) -> Option<HeaderMap> {
    match range.bytes_range {
        RequestRange::None => put_content_length(headers, range.bytes_len),
        RequestRange::AllFrom(start) => {
            put_content_range(headers, start..range.bytes_len, range.bytes_len)
        }
        RequestRange::Last(size) => put_content_range(
            headers,
            (range.bytes_len - size)..range.bytes_len,
            range.bytes_len,
        ),
        RequestRange::FromTo(start, end) => put_content_range(headers, start..end, range.bytes_len),
    }
}

/// Adds the HTTP `content-length` header to the given [`HeaderMap`].
///
/// Returns [`None`] if the conversion fails.
fn put_content_length(mut headers: HeaderMap, length: usize) -> Option<HeaderMap> {
    headers.typed_insert(ContentLength(l(length)?));
    Some(headers)
}

/// Adds the HTTP `content-length` and `content-range` headers to the given [`HeaderMap`].
///
/// Returns [`None`] if the conversion fails.
fn put_content_range(
    headers: HeaderMap,
    range: core::ops::Range<usize>,
    complete_length: usize,
) -> Option<HeaderMap> {
    let mut headers = put_content_length(headers, range.len())?;

    headers.typed_insert(
        ContentRange::bytes(l(range.start)?..l(range.end)?, l(complete_length)?).ok()?,
    );

    Some(headers)
}

/// Fallibly convert a `usize` length to a `u64` length with a very short method name.
///
/// The `l` stands for length.
fn l(x: usize) -> Option<u64> {
    x.try_into().ok()
}
