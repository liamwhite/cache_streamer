use cache_streamer_lib::types::{RequestRange, ResponseRange};
use headers::{ContentLength, ContentRange, HeaderMap, HeaderMapExt};
use range_header::ByteRangeBuilder;

/// Returns a [`HeaderMap`] containing the required headers to fetch the given [`RequestRange`].
///
/// If the range is [`RequestRange::None`], no headers are added. Otherwise, the appropriate
/// `range` header will be added.
pub fn request_range_headers(range: &RequestRange) -> HeaderMap {
    let mut headers = HeaderMap::new();
    let builder = ByteRangeBuilder::new();
    let builder = match range {
        RequestRange::None => Ok(builder),
        RequestRange::AllFrom(start) => builder.range(*start as u64..),
        RequestRange::FromTo(start, end) => builder.range((*start as u64)..(*end as u64)),
        RequestRange::Last(size) => builder.suffix(*size as u64),
    };

    if let Ok(h) = builder.and_then(|b| b.finish()) {
        headers.typed_insert(h);
    }

    headers
}

/// Adds the appropriate HTTP `content-length` and `content-range` headers from
/// the given [`ResponseRange`] to the given [`HeaderMap`].
///
/// If the response was not generated by a range request, then only the `content-length`
/// will be set.
///
/// Otherwise, the `content-length` header will be set to the length of the returned
/// range, and the `content-range` header will be set to include the returned range as
/// well as the complete length.
pub fn put_response_range(headers: HeaderMap, range: ResponseRange) -> HeaderMap {
    match range.bytes_range {
        RequestRange::None => put_content_length(headers, range.bytes_len),
        RequestRange::AllFrom(start) => {
            put_content_range(headers, start..range.bytes_len, range.bytes_len)
        }
        RequestRange::Last(size) => put_content_range(
            headers,
            (range.bytes_len - size)..range.bytes_len,
            range.bytes_len,
        ),
        RequestRange::FromTo(start, end) => put_content_range(headers, start..end, range.bytes_len),
    }
}

/// Adds the HTTP `content-length` header to the given [`HeaderMap`].
fn put_content_length(mut headers: HeaderMap, length: usize) -> HeaderMap {
    headers.typed_insert(ContentLength(length as u64));
    headers
}

/// Adds the HTTP `content-length` and `content-range` headers to the given [`HeaderMap`].
fn put_content_range(
    headers: HeaderMap,
    range: core::ops::Range<usize>,
    complete_length: usize,
) -> HeaderMap {
    let content_length = range.len();
    let mut headers = put_content_length(headers, content_length);

    headers.typed_insert(
        ContentRange::bytes(
            (range.start as u64)..(range.end as u64),
            complete_length as u64,
        )
        .expect("content range"),
    );

    headers
}
